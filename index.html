<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Bar Chart w/ Zoom</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #controls {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%); background: rgba(255,255,255,0.9);
      padding: 8px; border-radius: 4px; font-family: sans-serif;
      z-index: 10;
    }
    #controls label { margin-right: 8px; }
  </style>
</head>
<body>
  <div id="controls">
    <label for="zoom">Zoom:</label>
    <input type="range" id="zoom" min="10" max="200" value="50">
    <button id="parseBtn">Parse & Render</button>
  </div>
  <textarea id="rawData"
            placeholder="Paste your Receiver… lines here"
            style="position:absolute;top:50px;left:10px;width:300px;height:80px;z-index:10;"></textarea>

  <!-- three.js + orbit + d3 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
  // ─── Globals ─────────────────────────────────────────────────────────────
  let formattedData = [], objects = [], colorScale;

  // ─── 1. Setup three.js ─────────────────────────────────────────────────
  const scene    = new THREE.Scene();
  const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);
  scene.add(new THREE.DirectionalLight(0xffffff,1).position.set(0,1,1));
  scene.add(new THREE.AmbientLight(0xfffff4,1));

  camera.position.set(2,2,5);
  controls.target.set(2,1,0);
  controls.update();

  // ─── 2. Minimal parser (flatten 4×5×9 → 180) ────────────────────────────
  function parseMyLines(text) {
    const recs = [];
    text.split(/\r?\n/).forEach(line=>{
      for(let r=1;r<=4;r++){
        const m = line.match(new RegExp(`Receiver\\s*${r}:\\s*([\\d,\\s]+)-\\s*PotVals:\\s*([\\d,\\s]+)`));
        if(!m) continue;
        const reads = m[1].split(',').map(s=>+s);
        const pots  = m[2].split(',').map(s=>+s);
        reads.forEach((val,i)=> recs.push({ rawReading:val, potVal:pots[i] }));
      }
    });
    return recs;
  }

  // ─── 3. Render dispatcher ────────────────────────────────────────────────
  function render(data) {
    formattedData = data;
    // color by potVal
    const allP = formattedData.map(d=>d.potVal);
    colorScale = d3.scaleSequential(d3.interpolateYlOrRd)
                   .domain([d3.min(allP), d3.max(allP)]);
    // clear
    objects.forEach(o=>scene.remove(o));
    objects = [];
    // draw bars
    const wrap = 6, spacing=0.5;
    formattedData.forEach((d,i)=>{
      const col=i%wrap, row=Math.floor(i/wrap);
      const x=(wrap-1-col)*spacing, y=row*spacing, h=d.rawReading/2000;
      const geo = new THREE.BoxGeometry(0.4,0.4,h);
      const mat = new THREE.MeshPhongMaterial({ color: new THREE.Color(colorScale(d.potVal)), opaque:true, opacity:0.8 });
      const bar = new THREE.Mesh(geo,mat);
      bar.position.set(x,y,h/2);
      scene.add(bar);
      objects.push(bar);
    });
  }

  // ─── 4. Hooks ────────────────────────────────────────────────────────────
  document.getElementById('parseBtn').onclick = ()=>{
    const txt = document.getElementById('rawData').value;
    const d   = parseMyLines(txt);
    if(d.length) render(d);
    else alert('No records');
  };

  document.getElementById('zoom').addEventListener('input', e => {
    camera.zoom = +e.target.value/50;
    camera.updateProjectionMatrix();
  });

  // ─── 5. Animate ──────────────────────────────────────────────────────────
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene,camera);
  }
  animate();

  </script>
</body>
</html>
